import mongoose from "mongoose";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import User from "../models/user.model.js";
import {JWT_EXPIRES_IN, JWT_SECRET} from "../config/env.js";

// a req.body is an object containing data from the client (POST request)

export const signUp = async (req, res, next) => {
    //allows us to create a group of operations. Usefull when we must have all of them succeed.
    const session = await mongoose.startSession();
    session.startTransaction(); // upon this point the operations are a single atomic unit (basically this packages our operations into one). if any part fails, we can rollback.

    try {
        const {name, email, password} = req.body; // destructing object. From the request's body we assign the name, email, and password

        //check if our user aleady exists
        const existingUser = await User.findOne({email}); //accounts can only have a UNIQUE email, so if it is in use, this user exists

        if (existingUser) {
            const error = new Error('User already exists');
            error.status = 409;
            throw error;
        }

        // Hash password
        const salt = await bcrypt.genSalt(10);
        const hashedPassword = await bcrypt.hash(password, salt); // pass our plain text pass from the request and hash it

        //the session apart of this call tells us that it is apart of the transaction. If we did not do this we could not rollback if an error where to occur.
        // we pass an array with an object. meaning that the newUser is an array.
        const newUsers = await User.create([{name, email, password: hashedPassword}], { session });

        //when we create a new doc, this refers the first and only user doc that was created and saved. When we run this function, we can then call newUsers[0]. the _id is generated by mongo
        const token = jwt.sign({userId: newUsers[0]._id}, JWT_SECRET, {expiresIn: JWT_EXPIRES_IN}) //this is where we create the token for the account.
        //in we get the user id from mongo, our secret and sign it with our expiration in mind

        await session.commitTransaction(); // this goes through with the account creation | saves our changes
        session.endSession(); // end the session now that we are done. | closes client session
        res.status(201).json({ // pass a successful response with a json body
            success: true,
            message: 'User successfully created',
            data: {
                token, // our jwt token
                user: newUsers[0], // returns the user we just created, email, pass, name, createdat/updatedat
            }
        });
                //<-- notice how there are no next() calls here since these are the final route handlers for their respective paths.
    } catch(error) {
        await session.abortTransaction(); // this rollback all operations that were performed within the transaction ensuring nothing is saved to the database.
        session.endSession();
        next(error); // this goes to our error middleware. Even if this is not included in the path, we are using it in our app.js
    }
}

export const signIn = async (req, res, next) => {
    try {
        const {email, password } = req.body; // destruct assign email and password from the req body
        const user = await User.findOne({email}); // check if user exists

        if (!user) { // throw error if user does not exist
            const error = new Error('User not found');
            error.statusCode = 404;
            throw error;
        }

        const isPasswordValid = await bcrypt.compare(password, user.password); // we apply the same salt? to see if it matches with our hash pass. returns a true or false

        if (!isPasswordValid) { // throw an error when the password is incorrect.
            const error = new Error('Invalid password');
            error.statusCode = 401;
            throw error;
        }

        const token = jwt.sign({userId: user._id}, JWT_SECRET, {expiresIn: JWT_EXPIRES_IN}); // create a new token upon signing into this session?
        // yeah, we create a new token to act as a session token. Helps with ensureing this user is who they say they are.

        res.status(200).json({
            success: true,
            message: 'User signed in successfully',
            data: {
                token, // we pass the new session token
                user, // we return the user's info
            }
        })
    } catch (error)
    {
        next(error);
    }
}

export const signOut = async (req, res, next) => {
    // Implement sign up logic
}